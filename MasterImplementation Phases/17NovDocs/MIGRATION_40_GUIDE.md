# Migration 40 Guide - Soft Delete Schema Changes

## Overview

Migration 40 introduces database schema changes to support the soft delete and trash system in Duru Notes. This migration adds timestamp tracking columns to enable 30-day retention periods and automatic purging of deleted items.

**Migration Version**: 40
**Phase**: 1.1 - Soft Delete & Trash System
**Date**: January 2025
**Breaking Changes**: None (backward compatible)

## What Changed

### Drift Database (Local SQLite)

Migration 40 adds two new columns to three tables:

#### Tables Modified

1. **`local_notes`**
2. **`local_folders`**
3. **`note_tasks`**

#### New Columns

Each table receives:

| Column Name | Type | Nullable | Description |
|-------------|------|----------|-------------|
| `deleted_at` | INTEGER | Yes (NULL) | Unix epoch timestamp (UTC) when item was soft deleted |
| `scheduled_purge_at` | INTEGER | Yes (NULL) | Unix epoch timestamp (UTC) when item should be auto-purged |

**Default Values**: Both columns default to `NULL` for all existing rows.

**Data Type**: `INTEGER` storing Unix epoch milliseconds (UTC timezone).

**Indexing**: Indexes are created on `deleted_at` columns for efficient query performance.

### Supabase Database (Remote PostgreSQL)

A corresponding migration was created for Supabase with the following additions:

#### Tables Modified

1. **`notes`**
2. **`folders`**
3. **`note_tasks`**

#### New Columns

| Column Name | Type | Nullable | Description |
|-------------|------|----------|-------------|
| `deleted_at` | TIMESTAMPTZ | Yes (NULL) | Timestamp with timezone when item was deleted |
| `scheduled_purge_at` | TIMESTAMPTZ | Yes (NULL) | Timestamp with timezone for scheduled purge |

**Default Values**: `NULL` for all existing rows.

**Indexing**: Indexes created on `deleted_at` columns for performance.

**RLS Policies**: Row-level security policies updated to handle deleted items.

#### Audit Table

A new `trash_events` table was created for audit logging:

```sql
CREATE TABLE trash_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  item_type TEXT NOT NULL CHECK (item_type IN ('note', 'folder', 'task')),
  item_id UUID NOT NULL,
  item_title TEXT,
  event_type TEXT NOT NULL CHECK (event_type IN ('soft_delete', 'restore', 'permanent_delete')),
  deleted_at TIMESTAMPTZ,
  scheduled_purge_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_trash_events_user_id ON trash_events(user_id);
CREATE INDEX idx_trash_events_item_type ON trash_events(item_type);
CREATE INDEX idx_trash_events_event_type ON trash_events(event_type);
CREATE INDEX idx_trash_events_created_at ON trash_events(created_at);
```

## Migration File Location

### Drift Migration

**Path**: `lib/data/local/migrations/migration_40.dart`

**Generated Schema File**: `lib/data/local/app_db.g.dart` (auto-generated by Drift)

### Supabase Migration

**Path**: `supabase/migrations/20250115_add_soft_delete_columns.sql`

**Applied via**: Supabase CLI or Supabase Dashboard

## How to Apply the Migration

### Local Development (Drift)

The Drift migration runs automatically when you:

1. **Open the app** - Drift detects the schema version mismatch
2. **Auto-migration executes** - Migration 40 runs, adding columns and indexes
3. **App continues loading** - No user intervention required

**Manual Trigger (for testing):**

```dart
// In test setup or main.dart
final db = AppDb(NativeDatabase.memory());
await db.customStatement('PRAGMA foreign_keys = ON');
// Migration runs automatically on database initialization
```

### Production (Supabase)

#### Option 1: Supabase CLI (Recommended)

```bash
# Navigate to project root
cd /Users/onronder/duru-notes

# Check migration status
supabase migration list

# Apply pending migrations
supabase db push

# Verify migration applied
supabase migration list
```

#### Option 2: Supabase Dashboard

1. Navigate to Supabase Dashboard → Database → Migrations
2. Upload `supabase/migrations/20250115_add_soft_delete_columns.sql`
3. Click "Run Migration"
4. Verify success in migration history

#### Option 3: Direct SQL (Emergency)

```sql
-- Run in Supabase SQL Editor

-- Add columns to notes table
ALTER TABLE notes ADD COLUMN deleted_at TIMESTAMPTZ DEFAULT NULL;
ALTER TABLE notes ADD COLUMN scheduled_purge_at TIMESTAMPTZ DEFAULT NULL;
CREATE INDEX idx_notes_deleted_at ON notes(deleted_at);

-- Add columns to folders table
ALTER TABLE folders ADD COLUMN deleted_at TIMESTAMPTZ DEFAULT NULL;
ALTER TABLE folders ADD COLUMN scheduled_purge_at TIMESTAMPTZ DEFAULT NULL;
CREATE INDEX idx_folders_deleted_at ON folders(deleted_at);

-- Add columns to note_tasks table
ALTER TABLE note_tasks ADD COLUMN deleted_at TIMESTAMPTZ DEFAULT NULL;
ALTER TABLE note_tasks ADD COLUMN scheduled_purge_at TIMESTAMPTZ DEFAULT NULL;
CREATE INDEX idx_note_tasks_deleted_at ON note_tasks(deleted_at);
```

## Data Migration Considerations

### No Data Migration Required

This migration is **schema-only**. No existing data needs to be migrated because:

1. **New columns are nullable** - Existing rows automatically have `NULL` values
2. **Backward compatible** - Old code can read new schema (ignores new columns)
3. **Forward compatible** - New code handles `NULL` as "not deleted"

### Existing Data Behavior

After migration, all existing items:

- Have `deleted_at = NULL` (not deleted)
- Have `scheduled_purge_at = NULL` (no purge scheduled)
- Remain fully accessible and functional
- Are treated as active items (not in trash)

### Deleted Flag Computation

The `deleted` boolean field is computed from `deleted_at`:

```dart
// In domain entities
bool get deleted => deletedAt != null;
```

**No database column** for `deleted` boolean - it's derived from `deleted_at != NULL`.

## Testing the Migration

### Pre-Migration Checks

Before applying to production:

1. **Verify schema version** - Ensure Migration 40 is the latest
2. **Backup database** - Take snapshot of Supabase database
3. **Run on staging** - Apply to staging environment first
4. **Verify indexes created** - Check index creation succeeded

### Post-Migration Verification

After migration completes:

#### Local (Drift)

```dart
// In Flutter test file
void main() {
  test('Migration 40 adds soft delete columns', () async {
    final db = AppDb.forTesting(NativeDatabase.memory());

    // Query schema
    final result = await db.customSelect(
      "PRAGMA table_info(local_notes)"
    ).get();

    // Verify columns exist
    final columnNames = result.map((row) => row.data['name']).toList();
    expect(columnNames, contains('deleted_at'));
    expect(columnNames, contains('scheduled_purge_at'));

    await db.close();
  });
}
```

#### Remote (Supabase)

```sql
-- Run in Supabase SQL Editor

-- Verify columns exist in notes table
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'notes'
AND column_name IN ('deleted_at', 'scheduled_purge_at');

-- Expected output:
--  column_name         | data_type                   | is_nullable
-- ---------------------+-----------------------------+-------------
--  deleted_at          | timestamp with time zone    | YES
--  scheduled_purge_at  | timestamp with time zone    | YES

-- Verify indexes exist
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename IN ('notes', 'folders', 'note_tasks')
AND indexname LIKE '%deleted_at%';

-- Expected: 3 indexes (one per table)
```

### Test Scenarios

After migration, test:

1. **Soft delete a note** - Verify `deleted_at` and `scheduled_purge_at` are set
2. **Restore a note** - Verify timestamps are cleared
3. **Permanent delete** - Verify row is removed from database
4. **Query active items** - Verify deleted items are excluded
5. **Query trash** - Verify deleted items are returned
6. **Auto-purge** - Verify overdue items are purged

**Test Script:**

```dart
// In integration test
void main() {
  testWidgets('Migration 40 soft delete flow', (tester) async {
    final harness = IntegrationTestHarness();

    // Create a note
    final note = await harness.notesRepo.createOrUpdate(
      title: 'Test Note',
      body: 'Test Body',
    );
    expect(note!.deletedAt, isNull);
    expect(note.scheduledPurgeAt, isNull);

    // Soft delete the note
    await harness.notesRepo.deleteNote(note.id);

    // Verify timestamps are set
    final deletedNotes = await harness.notesRepo.getDeletedNotes();
    expect(deletedNotes, hasLength(1));
    expect(deletedNotes.first.deletedAt, isNotNull);
    expect(deletedNotes.first.scheduledPurgeAt, isNotNull);

    // Verify scheduled purge is ~30 days from now
    final purgeDate = deletedNotes.first.scheduledPurgeAt!;
    final expectedDate = DateTime.now().add(Duration(days: 30));
    final difference = purgeDate.difference(expectedDate).inHours.abs();
    expect(difference, lessThan(24)); // Within 24 hours

    await harness.dispose();
  });
}
```

## Rollback Procedure

If migration causes issues, follow this rollback process:

### Local (Drift)

**Note**: Drift migrations cannot be rolled back automatically. To revert:

1. **Delete app data** - Clear app cache and data on device
2. **Reinstall app** - Install version without Migration 40
3. **Restore from backup** - If critical data was lost

**Best Practice**: Don't rollback Drift migrations in production. Test thoroughly in development.

### Remote (Supabase)

#### Option 1: Rollback Migration (Recommended)

```sql
-- Create rollback migration file
-- supabase/migrations/20250116_rollback_soft_delete.sql

-- Drop indexes
DROP INDEX IF EXISTS idx_notes_deleted_at;
DROP INDEX IF EXISTS idx_folders_deleted_at;
DROP INDEX IF EXISTS idx_note_tasks_deleted_at;

-- Drop columns
ALTER TABLE notes DROP COLUMN IF EXISTS deleted_at;
ALTER TABLE notes DROP COLUMN IF EXISTS scheduled_purge_at;

ALTER TABLE folders DROP COLUMN IF EXISTS deleted_at;
ALTER TABLE folders DROP COLUMN IF EXISTS scheduled_purge_at;

ALTER TABLE note_tasks DROP COLUMN IF EXISTS deleted_at;
ALTER TABLE note_tasks DROP COLUMN IF EXISTS scheduled_purge_at;

-- Drop audit table
DROP TABLE IF EXISTS trash_events;
```

**Apply rollback:**

```bash
supabase db push
```

#### Option 2: Database Restore (Emergency)

```bash
# Restore from backup taken before migration
supabase db restore <backup-id>
```

### Data Loss Considerations

Rolling back will **lose**:

- All soft delete timestamps (items in trash will be lost)
- Trash audit logs
- Scheduled purge information

**Mitigation**: Export trash data before rollback if critical.

## Performance Impact

### Query Performance

**Before Migration 40:**
- Queries filter on `deleted` boolean column (if it existed)
- No indexes on delete-related columns

**After Migration 40:**
- Queries filter on `deleted_at IS NULL`
- Indexes on `deleted_at` provide fast filtering
- **Expected speedup**: 10-100x for trash queries on large datasets

### Storage Impact

**Per Table:**
- 2 new columns × 8 bytes (INTEGER) = 16 bytes per row
- 1 index on `deleted_at` ≈ 8 bytes per row

**Total Overhead**: ~24 bytes per row

**Example**: 10,000 notes → ~240 KB additional storage (negligible)

### Migration Duration

**Expected Duration:**
- **Drift (local)**: < 1 second (runs on app startup, in-memory database)
- **Supabase (remote)**:
  - Small database (< 10K rows): < 5 seconds
  - Medium database (10K-100K rows): 5-30 seconds
  - Large database (> 100K rows): 30-120 seconds

**Downtime**: None (migrations run without locking tables)

## Common Issues

### Issue 1: "Migration 40 not found"

**Cause**: Migration file not included in build or not generated.

**Solution**:
```bash
flutter packages pub run build_runner build --delete-conflicting-outputs
```

### Issue 2: "Column already exists"

**Cause**: Migration was partially applied or run multiple times.

**Solution**:
```sql
-- Check if columns exist
SELECT column_name FROM information_schema.columns
WHERE table_name = 'notes' AND column_name IN ('deleted_at', 'scheduled_purge_at');

-- If they exist, manually mark migration as complete
-- Or drop and re-run migration
```

### Issue 3: "Index creation failed"

**Cause**: Index name conflicts or insufficient permissions.

**Solution**:
```sql
-- Drop existing index if it conflicts
DROP INDEX IF EXISTS idx_notes_deleted_at;

-- Recreate with unique name
CREATE INDEX idx_notes_deleted_at_v2 ON notes(deleted_at);
```

### Issue 4: "RLS policy conflicts"

**Cause**: Existing RLS policies don't account for new columns.

**Solution**: Update RLS policies to handle `deleted_at`:

```sql
-- Example: Update policy to exclude deleted items
CREATE POLICY "Users can view their own active notes"
ON notes FOR SELECT
USING (auth.uid() = user_id AND deleted_at IS NULL);
```

## Security Considerations

### Row-Level Security (RLS)

Migration 40 requires RLS policy updates:

1. **Active items policy** - Exclude `deleted_at IS NOT NULL`
2. **Trash items policy** - Include `deleted_at IS NOT NULL`
3. **Permanent delete policy** - Allow deletion of soft-deleted items

**Example Policies:**

```sql
-- Active notes (exclude deleted)
CREATE POLICY "Users view active notes"
ON notes FOR SELECT
USING (auth.uid() = user_id AND deleted_at IS NULL);

-- Trash notes (include deleted)
CREATE POLICY "Users view trash notes"
ON notes FOR SELECT
USING (auth.uid() = user_id AND deleted_at IS NOT NULL);

-- Permanent delete (only soft-deleted items)
CREATE POLICY "Users delete trash notes"
ON notes FOR DELETE
USING (auth.uid() = user_id AND deleted_at IS NOT NULL);
```

### Encryption

- **New columns are NOT encrypted** - `deleted_at` and `scheduled_purge_at` are metadata
- **Content remains encrypted** - Title, body, and sensitive fields still encrypted
- **Audit log titles are decrypted** - `trash_events.item_title` stores plaintext for debugging

### Permissions

Migration requires:

- **Drift**: No special permissions (runs in app context)
- **Supabase**: `ALTER TABLE` privilege (admin/service role)

## API Compatibility

### Backward Compatibility

**Old Code (Pre-Migration 40):**
```dart
// Code that doesn't know about soft delete
final notes = await db.select(db.localNotes).get();
```

**Behavior After Migration:**
- Works without changes
- Returns all rows (including deleted items)
- `deleted_at` and `scheduled_purge_at` are ignored

**Migration Path**: Update queries to filter deleted items:

```dart
// New code (Post-Migration 40)
final activeNotes = await (db.select(db.localNotes)
  ..where((tbl) => isNull(tbl.deletedAt)))
  .get();
```

### Forward Compatibility

**New Code (Post-Migration 40):**
```dart
// Code that expects soft delete columns
final deletedNotes = await (db.select(db.localNotes)
  ..where((tbl) => isNotNull(tbl.deletedAt)))
  .get();
```

**Behavior Without Migration:**
- Will fail if migration not applied
- Error: "no such column: deleted_at"

**Migration Path**: Ensure Migration 40 is applied before deploying new code.

## Developer Checklist

Before deploying code that depends on Migration 40:

- [ ] Migration 40 file exists: `lib/data/local/migrations/migration_40.dart`
- [ ] Supabase migration file exists: `supabase/migrations/20250115_add_soft_delete_columns.sql`
- [ ] Drift schema regenerated: `flutter packages pub run build_runner build`
- [ ] Domain entities updated: `Note`, `Folder`, `Task` have `deletedAt` and `scheduledPurgeAt`
- [ ] Mappers updated: Handle new timestamp fields
- [ ] Repository methods updated: `deleteNote()`, `restoreNote()`, `permanentlyDeleteNote()`
- [ ] Tests passing: Unit tests, widget tests, integration tests
- [ ] Supabase migration applied: Run `supabase db push` on staging
- [ ] RLS policies updated: Active items exclude deleted, trash items include deleted
- [ ] Indexes verified: `idx_notes_deleted_at`, `idx_folders_deleted_at`, `idx_note_tasks_deleted_at`
- [ ] Audit table created: `trash_events` with RLS policies
- [ ] Performance tested: Query performance on large datasets
- [ ] Rollback plan prepared: Backup database before production deployment

## Monitoring

After migration, monitor:

1. **Database size** - Should increase slightly (24 bytes per row)
2. **Query performance** - Should improve for trash queries
3. **Error logs** - Watch for migration-related errors
4. **User reports** - Monitor for trash feature issues

**Metrics to Track:**

- Soft delete operations per day
- Restore operations per day
- Permanent delete operations per day
- Auto-purge operations per day
- Average trash size per user
- Peak trash size (max items per user)

**Alerting Thresholds:**

- Auto-purge failures > 5% of attempts
- Permanent delete failures > 1% of attempts
- Trash query latency > 1 second
- Database size growth > 10% per week

## FAQ

### Can I skip Migration 40?

No. The soft delete feature requires Migration 40. Without it, the app will crash when accessing trash-related features.

### What if I already have a `deleted` column?

Migration 40 adds `deleted_at` and `scheduled_purge_at`, not `deleted`. The `deleted` boolean is computed from `deleted_at != null`. Remove any existing `deleted` column before applying Migration 40.

### Can I customize the column names?

Not recommended. The codebase expects `deleted_at` and `scheduled_purge_at`. Changing column names requires updating all repository code, mappers, and queries.

### Do I need to update my app after migration?

Yes. Older app versions won't understand the new schema and may behave unexpectedly. Ensure all users update to the version with Migration 40 support.

### What happens to items deleted before Migration 40?

Before Migration 40, if items were truly deleted (not soft deleted), they cannot be recovered. Migration 40 only affects items deleted after the migration is applied.

### Can I change the retention period from 30 days?

The 30-day retention is hardcoded in `TrashService.retentionPeriod`. To change it:

```dart
// In lib/services/trash_service.dart
static const Duration retentionPeriod = Duration(days: 30); // Change this value
```

Future versions may make this configurable per-user.

## Additional Resources

- **Soft Delete Architecture**: See `SOFT_DELETE_ARCHITECTURE.md` for technical details
- **Trash Feature Guide**: See `TRASH_FEATURE_USER_GUIDE.md` for user-facing documentation
- **Drift Documentation**: https://drift.simonbinder.eu/docs/migrations/
- **Supabase Migrations**: https://supabase.com/docs/guides/database/migrations

## Support

For migration issues:

1. Check this guide's "Common Issues" section
2. Review migration logs: `flutter run --verbose`
3. Verify Supabase migration status: `supabase migration list`
4. Contact development team with error logs and database schema dump

---

**Migration Version**: 40
**Last Updated**: January 2025
**Phase**: 1.1 - Soft Delete & Trash System
