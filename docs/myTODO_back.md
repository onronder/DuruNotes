1. Organization (Folders, Tags, Saved Searches, Pinning, Sorting)
* 	•	Implement Folders: Establish a full folder system for organizing notes. The codebase already initializes folder loading and displays placeholder chips (skeleton UI) for folders on startupGitHubGitHub, so the groundwork is in place. Next steps include creating CRUD functionality for folders (create, rename, delete) and linking notes to folders. This involves a folder data model (and database table if not already), a UI component for folder navigation (e.g. a sidebar on tablets or a dropdown on phones), and the ability to move notes between folders (possibly via a folder picker dialog or drag-and-drop in the list). Ensure that selecting a folder filters the notes list to only show notes in that folder. After implementation, test thoroughly that notes appear under the correct folder, including the special Inbox/Incoming Mail folder, and that folder changes sync across devices (likely using the existing folderRealtimeServiceProvider for real-time syncGitHub). Also verify the skeleton placeholders swap to real folder chips once data loadsGitHub, and that no blank gap appears during loading.
* 	•	Saved Searches & Tag Filtering: Provide quick-access filters for common note categories using the SavedSearchChips UI that is partially implemented. According to the QA checklist, four preset chips should appear (📎 Attachments, 📧 Email Notes, 🌐 Web Clips, 📥 Inbox)GitHub. We need to ensure these chips are functional: tapping each chip should apply the correct filter (e.g. Attachments chip filters notes with attachments, Email Notes shows email-in notes, etc.). This requires implementing the filter logic (likely by using tags/metadata: e.g. has:attachment, from:email as per the QA specs). The app’s database should be queried for notes matching those criteria (the code that fetches tag countsGitHub suggests tags like #Email, #Web, #Attachment are already tracked). We should also allow custom saved searches if planned – meaning users can save any search query and have it appear as a chip or menu item. Micro-tasks here include building a UI to save a search (give it a name and perhaps an icon), storing those in the database, and rendering them similarly to preset chips. Additionally, implement the search token parsing as outlined (support queries like folder:Inbox, has:attachment AND keyword, etc.)GitHub. Finally, test all scenarios from the QA checklist: combined tokens, case insensitivity, edge cases (no results, empty folders)GitHubGitHub to ensure the search and filter system is robust.
* 	•	Pinning Notes (Favorites): Introduce the ability to pin important notes to the top of lists for quick access. This will involve adding a pin attribute to notes (e.g. a boolean field in the note model) and updating the UI to mark a note as pinned (perhaps a star ⭐️ icon in note options). In the notes list, pinned notes should be displayed at the top (maybe in their own section or with a pin icon indicator). Micro-tasks include updating the database schema to record pinned status, adding a toggle action in the note context menu or toolbar (“Pin/Unpin Note”), and modifying the query that fetches notes so that pinned notes are ordered first (while still respecting folder filtering or search). We should also allow unpinning and ensure the UI updates immediately when a note is pinned/unpinned. Test that this works across sync – e.g. pin a note on one device, ensure it appears pinned on another. Also consider the interaction with sorting: if a user sorts by title or date, pinned notes might either always float on top (common behavior) or perhaps the user can toggle whether sorting applies to pinned notes or not. For now, a reasonable approach is always show pinned notes first, sorted by pin order or by the current sort after grouping.
* 	•	Custom Sorting Options: Expand the notes list sorting beyond the default (currently by date). The UI already has a menu placeholder for “Sort”GitHub. We need to implement the actual sorting choices and logic. Likely sort options include: Date Created, Date Modified, Title (A–Z), and perhaps Manual (if we allow user to reorder). Micro-tasks: create a sort-selection dialog or submenu that lists these options (tapping “Sort” could pop up a list of sorting criteria). Use the state (like the _sortBy variable already in the code) to store the current sort order and trigger the notes list provider to re-fetch or re-order notes accordingly. Ensure this sort order preference is persisted (possibly in user settings/local storage) so the app remembers the choice. If manual sorting or custom ordering is desired in future, that could be more complex (involving drag-and-drop reordering of notes in a folder), but initially, implementing the three basic automated sorts (date modified (newest/oldest), title) should suffice. Also, update the UI indicator or menu to reflect the active sort (for example, tick mark next to the active sort option). After implementing, test sorting with various note sets: titles starting with numbers, dates in the past, etc., and ensure it works in conjunction with folder filters and pinned notes (e.g. pinned notes remain at top regardless of sort, if that rule is decided).
2. Quick-Capture (Share Sheet, Widgets, Templates)
* 	•	System Share Extension (iOS & Android): Develop a share sheet extension so users can send content into DuruNotes from other apps. On iOS, this means creating an Action Extension or Share Extension target in the Xcode project via Flutter (which likely involves some native code or use of the flutter_share plugin if available). The extension should accept common data types: text snippets, URLs, images, etc. When a user shares to DuruNotes, the extension can create a new note with that content (e.g. if sharing a webpage from Safari, grab the URL and page title into the note; if sharing text, put it in the note body; if an image, add as attachment). Consider adding a default tag or metadata for notes created via share (similar to how email-in notes are tagged #EmailGitHub or web clips #Web). On Android, implement an intent-filter to receive shared content. Flutter can handle incoming intents using an external package or through platform channels. Likely, we’ll start an instance of the app (or a headless receiver) that adds the data to a new note. Key micro-tasks: set up the platform-specific code for receiving shares, pass the data to Flutter (maybe via method channel), and implement logic in Dart to save a new note from that data. Also, if the app is locked or requires authentication (if any security in place), decide how to handle that for quick captures (perhaps queue the note until app is unlocked). Testing: share various content types from different apps (browser, gallery, notes) on both iOS and Android to verify the note is created correctly with the shared content and that no data is lost (e.g. multi-image share, or a URL with no text).
* 	•	Home Screen Widget (Quick Note): Provide a widget on mobile platforms for fast note-taking or viewing. For iOS 16+, Flutter supports widgets via additional packages (since iOS widgets are essentially SwiftUI views, we might need to write a bit of native code or use flutter_widgetkit). The widget could be something simple like a “New Note” shortcut or a small list of recent notes. A minimal valuable widget might be a Quick Add button: tapping it deep-links into the app’s new-note screen, or even directly opens a text input overlay to capture a note without fully launching the app (this might need iOS App Quick Actions or a widget with a textfield, though interactive widgets on iOS are limited). On Android, implement an App Widget that could have buttons (New Note, maybe shortcuts to specific folders or recent notes). Android widgets allow some interactivity; for instance, one design is a scrollable list of recent notes and a "+" button. To implement: use Flutter’s widget support (there are packages that simplify this) or write native widget code and have it communicate with Flutter (via App Links or an isolate). Initially, focusing on a simple "New Note" one-tap widget might be best. Also consider App Shortcut (long-press app icon to get quick actions like New Note, Search) – on iOS this is done via Info.plist UIApplicationShortcutItems, on Android via manifest shortcuts. These are not home screen widgets but related quick-capture features. Ensure the widget updates appropriately (for example, if showing a count of notes or last note title, it refreshes when notes change – possibly using App Groups on iOS or similar mechanism for shared data). Testing: add the widget on both platforms, tap it to create notes, and verify it works from various states (app running in background vs closed).
* 	•	Note Templates: Introduce templates to speed up capturing structured notes. Templates could be a set of pre-defined note contents (like "Meeting Notes", "To-Do List", etc.) that the user can choose from when creating a new note. A straightforward implementation is to ship a few default template files and allow the user to duplicate them. For example, have a hidden “Templates” folder with notes that serve as templates, or store template content in a JSON config. Micro-tasks: create a UI in the "new note" flow that lets the user select a template (e.g. a New Note menu that has a submenu or dialog: New Blank Note, From Template → [Meeting, Journal, etc]). If using a Templates folder approach, the action would basically duplicate the template note’s content into a new note. Ensure formatting (checklists, headings, etc.) in the template is preserved. Also allow users to create their own templates eventually – perhaps by saving a note as template (not mandatory in first version, but keep in mind). Implement at least 2-3 useful default templates for now. Testing: create notes from each template and verify the content matches the template, and that template notes themselves aren’t accidentally shown as normal notes (if using a special folder, maybe hide that folder from normal view or mark templates distinctly).
3. Import/Export Polishing
* 	•	Finalize Evernote ENEX Import: Many users migrating will want to import Evernote data, so ensure the .enex import is solid. The UI already offers “Evernote Export” in the import dialogGitHub and calls importService.importEnex(...) when an .enex file is chosenGitHub. We need to implement importEnex in the import service if not done: parse the Evernote XML format. Micro-tasks include: using an XML parser to iterate through notes, extracting titles, content (Evernote content is in an ENEX XML, often with their proprietary XHTML format), attachments (resources in ENEX are base64-encoded). Map Evernote content to DuruNotes format – possibly converting ENEX's inline formatting to Markdown or HTML that our editor can render. Also handle Evernote-specific data: tags (ENEX notes have <tag> elements), created and updated timestamps, maybe geolocation (if present, could ignore at first), and note attachments (ENEX resources have data and MIME info). Save each imported note in the database, potentially placing all imported notes into a new folder (maybe a folder named after the ENEX filename or "Imported from Evernote"). If the ENEX represents a single notebook export, perhaps allow the user to choose a target folder or create one automatically. Testing: use a variety of ENEX files – a small one with a couple of notes, and a large one with hundreds of notes – to ensure performance and correctness. Verify that formatting in Evernote (lists, bold, images, etc.) comes through reasonably. Some fine-tuning might be needed for things like Evernote checkboxes (which come as [ ] or a specific ENEX <en-todo> tag) to our checklist format. Also ensure that if an import fails for a particular note, it continues with others and reports the error gracefully.
* 	•	Obsidian Vault Import: Implement the ability to import a directory of Markdown files (Obsidian or general markdown export). The UI has an option for “Obsidian Vault”GitHub which triggers a directory picker. We need _processObsidianImport to walk the directory. Micro-tasks: allow the user to pick a folder (already using FilePicker.getDirectoryPath()GitHub), then scan for .md files. Preserve the folder structure: for example, if the vault has subfolders, recreate those as DuruNotes folders (or we could import everything into one folder and prepend folder names to titles – but better to actually mirror structure). For each Markdown file, read its content and use the existing importMarkdown logic (which likely already exists for single files). Also import images or attachments: Obsidian vaults often have an "attachments" folder; we should detect images and copy them into our notes as attachments, updating image links in the Markdown to the new location if needed. This can be complex, so initially maybe assume images embedded via relative paths can be handled if we import them alongside notes. If the vault has wiki-style links between notes (e.g., [[Note Title]]), those won’t resolve in our app unless we implement internal linking; we might leave those as plain text for now or convert them to something identifiable for future. Testing: take a sample Obsidian vault with a few folders and markdown files (including one with an image embed and one with an wiki link) and run the import. Verify that all files become notes, folder hierarchy is maintained, and content is intact (with basic formatting). If something isn’t supported (like Obsidian front-matter or special syntax), ensure it doesn’t crash the import (we can strip YAML front matter, for example). If performance is an issue on large vaults, consider importing in an isolate or showing progress (the UI already uses a progress dialog for importsGitHub, which we should update as we import many files).
* 	•	Polish Markdown & PDF Export: The export functionality is largely implemented with options for Markdown, PDF, and HTMLGitHub. We should refine this to ensure all note content is exported cleanly. For Markdown export: verify that special elements like checkboxes, attachments, and tables (if any) are correctly represented. For example, a checklist item should export as - [x] or - [ ] in Markdown. Images/attachments could be exported as files with references in the Markdown (e.g., ![](attachments/image1.png) and in the export folder, an "attachments" subfolder with the actual file). For PDF export: ensure the PDF generation captures the note’s rich text styling. Likely we use an HTML-to-PDF or a rendering of the widget to PDF. We may need to embed images in the PDF and apply basic styling (fonts, headings). Check that long notes paginate properly and that PDFs are not enormous in file size (maybe compress images). HTML export: ensure that the HTML files include necessary CSS or inline styles so that when opened in a browser the note looks readable. Possibly include a simple stylesheet for things like headings and lists. Micro-tasks also include handling edge cases: what if a note has no title – use first line or "Untitled" as file name for export. If multiple notes exported at once, maybe zip them (currently it appears it exports multiple files individually; perhaps offering a ZIP option could be a nice polish but not strictly necessary if the OS handles multi-file selection). Also test non-English characters and emoji in exports for encoding issues. After polishing, do a test export of a batch of notes that includes various content (text, images, lists, code blocks, etc.) and inspect the output files manually to ensure fidelity.
* 	•	ENEX/Export Metadata & Integrity: As a polish step, verify that metadata like created/updated timestamps and tags are handled in import/export. For ENEX import, set the note’s timestamps to those from Evernote (so original create dates are not lost). For exports, consider optionally including metadata: e.g., for Markdown maybe prepend front matter with create date, tags, etc., or include them in PDF properties. This might be optional or minimal, but at least tags could be output (perhaps as a list at end of MD or a field in HTML). Another polish is to ensure security: if notes are encrypted (the app has an encryption hook in E2.5), exporting should decrypt content before exporting so the output is usable. If encryption is enabled, prompt the user for password if needed to export. Similarly, when importing, decide how to handle if imported data should be immediately encrypted (likely yes if user’s notes DB is encrypted). These details ensure that the import/export feature is production-ready and instills trust that users can get their data in and out reliably.
4. Tasks & Reminders (Checkboxes → Tasks, Agenda & Alerts)
* 	•	Checkbox → Task Conversion: Extend the existing checklist feature to formally support tasks. The editor already allows inserting checkboxes (as part of the formatting toolbar, which is done in Editor V2). We need to give those checkboxes additional behavior/state, turning them into tasks. At a basic level, every checklist item can be considered a “task” with a completion status (checked = done). To enrich this, we can allow each task to have metadata like a due date or priority. Implementation could be done in a few ways: one approach is to detect special syntax in the note text (for example, appending (@due 2023-12-01) to a line could indicate a due date) – but that’s not very user-friendly. Better is a UI approach: when the user focuses or long-presses a checkbox line, show options to “Add Reminder/Date” or “Convert to Task” which opens a date-picker and maybe a small form for due date and an optional reminder alarm. Under the hood, we might store these in a separate tasks table linking back to the note and checklist line (to avoid altering the note text to store metadata). Alternatively, we could embed a hidden marker in the note text (like an inline HTML comment or a special character) to identify the due date – but that’s hacky. A cleaner approach: maintain a mapping of note ID + line index to a task object (with due date, etc.) in the database. Micro-tasks: design the data model for tasks (could simply reuse note ID, text snippet, a bool done, a DateTime for due, maybe a string for reminder time or recurrence if later). Provide the UI to set a due date on a task – e.g., tapping an “Add reminder” icon on a checklist item triggers a date-time picker. Once set, visually indicate it in the note (could append a small calendar icon and date next to the checkbox line in the UI). Also, ensure that when a checkbox is checked off, if it had a due date, we mark the task completed (possibly store completion timestamp if needed). If a user unchecks it, mark as not done again. This essentially ties the note’s content to a lightweight task management system.
* 	•	Task List & Calendar View: Create dedicated views to manage tasks across all notes. Many users will want to see a summary of all their to-dos without hunting through notes. Implement a Task List screen that aggregates all open (incomplete) tasks from every note. Each entry can display the task description (the text of the checklist line), maybe the note title it belongs to (for context), and the due date if any. Users should be able to check-off tasks right from this list (which should also update the note). Group tasks by date (e.g. overdue, due today, tomorrow, later, or no date). For a calendar view, consider a monthly calendar that highlights days with tasks due. Selecting a date shows tasks due that day. This could be a separate Calendar tab or integrated into the task list with a calendar widget at top. Micro-tasks: implement a provider or query that collects all tasks (note ID, text, due date, done status) from the notes database. If tasks are stored as separate records, that’s straightforward. If not, we might scan notes for checklist syntax – but that’s inefficient; better to store tasks explicitly when added. Build the UI for the Task List: maybe a TaskListScreen with sections “Overdue”, “Today”, “Upcoming”, etc. For each task, show a checkbox and label, and perhaps a small link or button to open the parent note (so user can jump to full note context). Also implement the Calendar: possibly use a Flutter calendar widget or just a grid of days; show markers on days that have tasks. The user can tap a day to filter tasks by that date. Ensure the task list updates in real-time as tasks are completed or added (Riverpod providers can help here, e.g., invalidate the task provider on changes). Testing: create several tasks with various due dates, then check the task list and calendar – verify tasks appear in correct sections and dates. Mark some done via the task list and ensure they get checked off in the original note and disappear from "open tasks" view (maybe move to a “Completed” section if we show that or simply remove). Also test tasks with no due date – they might appear in a "No date" or "Someday" section.
* 	•	Reminders & Notifications: Enable optional notifications for tasks with due dates. Users should be reminded when a task is coming due. Implement local notifications on each platform: on iOS, use flutter_local_notifications or native APIs to schedule a notification at the specified time; on Android, do similarly. Micro-tasks: when a user sets a due date/time on a task and toggles a “Remind me” option, schedule a notification for that datetime. The notification could say “Reminder: [Task text] in [Note Title]”. Tapping it could deep-link into the app, opening that note or the task list. Also consider a daily summary notification if many tasks due on a day (optional enhancement). We must handle timezone properly and device reboots (on Android, reschedule notifications after reboot via a BroadcastReceiver, perhaps the plugin handles it). Additionally, provide a way to see and manage reminders – e.g., a “Notifications” or simply by editing the task to remove the reminder if needed. Ensure that completing a task cancels its pending notification (so you don’t get reminded for something already done). Testing: schedule a reminder for a task in the next minute or two to see that a notification fires on both iOS and Android (handling permission prompts on iOS the first time). Test that tapping the notification opens the app to the relevant screen. Also test that if you mark the task done before the time, the notification is canceled.
* 	•	Integration with External Calendars (future consideration): Not strictly needed for initial implementation, but design with the possibility in mind. For example, maybe later allow exporting tasks with due dates to an iCal feed or syncing with Google Calendar or Apple Reminders. For now, ensure our data model could accommodate an ID or link if we ever integrate with such services. This is just a note to keep the architecture flexible.
* 	•	Usability & UX: Make sure that adding tasks doesn’t disrupt the simplicity of note-taking. The UI for due dates and reminders should be discoverable but not intrusive. Perhaps show a small calendar icon on a checklist line – tapping it opens date picker. If no due date, icon could be hollow; if there is one, show filled icon or date text. Also, possibly highlight overdue tasks in the note (e.g., date in red) as visual cues. Another UX consideration: if a note is purely a task list, maybe allow converting it to a “task note” with a summary of how many tasks open, etc., but that's extra polish. Testing UX: have someone use the feature to add tasks, see if they understand how to set a reminder, and adjust as needed (maybe tooltips or a brief tutorial overlay when first using tasks).