Hereâ€™s the updated pre-paywall to-do list with Editor V2 moved to the top:
- [ ] Handwriting & Drawing
- [ ] On-device AI (semantic search, auto-tags, summaries)
- [ ] Organization (Folders, Saved Searches, Pinning/Sorting)
- [ ] Tasks & Reminders (checkbox â†’ task + calendar view)
- [ ] Quick-Capture (widgets, share sheet, templates)
- [ ] Secure Sharing (password-protected links)
- [ ] Import/Export polish (ENEX import, MD/PDF export)
- [ ] Paywall scaffolding (flags & gating only)
- [x] Web Clipper & Email-in
- [x] E2.7: Tests (derivation, debounce, legacy load), perf checks
- [x] E2.6: Title derivation + safe backfill to notes.title
- [x] E2.5: Autosave (debounced), encryption hook, repo save function
- [x] E2.4: Formatting toolbar (headings, bold/italic, list, checklist, quote, code)
- [x] E2.3: Keyboard behaviors (Enter from H1 â†’ body; Backspace at body start â†’ H1)
- [x] E2.2: First-line-as-H1 behavior (placeholder â€œTitleâ€¦â€, full-bleed)
- [x] E2.1: Editor V2 scaffold & routing (new notes open Editor V2; legacy notes supported)
- [x] Editor V2 â€“ full-bleed new note UX (Apple-style)



To overcome this, Duruâ€™s marketing must clearly convey what new thing it brings to the table (e.g. â€œTake notes to the next level with AIâ€ or â€œFinally, a notes app that respects your privacy and works offlineâ€).



Next Feature Implementation Plan
Following the completion of core editor improvements, the next phase is to implement key features that enhance noteÂ organization, capture, and advanced functionality. We will tackle each macro-level feature in priority order, and break down the micro-tasks needed for implementation. The strategy is to focus on foundational features (like folders and quick capture) first, then layer on tasks, AI, and sharing, all while preparing for premium gating. Below is a detailed plan:
1. Organization (Folders, Tags, Saved Searches, Pinning, Sorting)
* 	â€¢	Implement Folders:Â Establish a full folder system for organizing notes. The codebase already initializes folder loading and displays placeholder chips (skeleton UI) for folders on startupGitHubGitHub, so the groundwork is in place. Next steps include creating CRUD functionality for folders (create, rename, delete) and linking notes to folders. This involves a folder data model (and database table if not already), a UI component for folder navigation (e.g. a sidebar on tablets or a dropdown on phones), and the ability to move notes between folders (possibly via aÂ folder pickerÂ dialog or drag-and-drop in the list). Ensure that selecting a folder filters the notes list to only show notes in that folder. After implementation, test thoroughly that notes appear under the correct folder, including the specialÂ Inbox/Incoming MailÂ folder, and that folder changes sync across devices (likely using the existingÂ folderRealtimeServiceProviderÂ for real-time syncGitHub). Also verify the skeleton placeholders swap to real folder chips once data loadsGitHub, and that no blank gap appears during loading.
* 	â€¢	Saved Searches & Tag Filtering:Â Provide quick-access filters for common note categories using theÂ SavedSearchChipsÂ UI that is partially implemented. According to the QA checklist, four preset chips should appear (ğŸ“ Attachments, ğŸ“§ Email Notes, ğŸŒ Web Clips, ğŸ“¥ Inbox)GitHub. We need to ensure these chips are functional: tapping each chip should apply the correct filter (e.g.Â AttachmentsÂ chip filters notes with attachments,Â Email NotesÂ shows email-in notes, etc.). This requires implementing the filter logic (likely by using tags/metadata: e.g.Â has:attachment,Â from:emailÂ as per the QA specs). The appâ€™s database should be queried for notes matching those criteria (the code that fetches tag countsGitHubÂ suggests tags like #Email, #Web, #Attachment are already tracked). We should also allowÂ custom saved searchesÂ if planned â€“ meaning users can save any search query and have it appear as a chip or menu item. Micro-tasks here include building a UI to save a search (give it a name and perhaps an icon), storing those in the database, and rendering them similarly to preset chips. Additionally, implement the search token parsing as outlined (support queries likeÂ folder:Inbox,Â has:attachment AND keyword, etc.)GitHub. Finally, test all scenarios from the QA checklist: combined tokens, case insensitivity, edge cases (no results, empty folders)GitHubGitHubÂ to ensure the search and filter system is robust.
* 	â€¢	Pinning Notes (Favorites):Â Introduce the ability to pin important notes to the top of lists for quick access. This will involve adding aÂ pinÂ attribute to notes (e.g. a boolean field in the note model) and updating the UI to mark a note as pinned (perhaps a star â­ï¸ icon in note options). In the notes list, pinned notes should be displayed at the top (maybe in their own section or with a pin icon indicator). Micro-tasks include updating the database schema to record pinned status, adding a toggle action in the note context menu or toolbar (â€œPin/Unpin Noteâ€), and modifying the query that fetches notes so that pinned notes are ordered first (while still respecting folder filtering or search). We should also allow unpinning and ensure the UI updates immediately when a note is pinned/unpinned. Test that this works across sync â€“ e.g. pin a note on one device, ensure it appears pinned on another. Also consider the interaction with sorting: if a user sorts by title or date, pinned notes might either always float on top (common behavior) or perhaps the user can toggle whether sorting applies to pinned notes or not. For now, a reasonable approach isÂ always show pinned notes first, sorted by pin order or by the current sort after grouping.
* 	â€¢	Custom Sorting Options:Â Expand the notes list sorting beyond the default (currently by date). The UI already has a menu placeholder for â€œSortâ€GitHub. We need to implement the actual sorting choices and logic. Likely sort options include:Â Date Created,Â Date Modified,Â Title (Aâ€“Z), and perhapsÂ ManualÂ (if we allow user to reorder). Micro-tasks: create a sort-selection dialog or submenu that lists these options (tapping â€œSortâ€ could pop up a list of sorting criteria). Use the state (like theÂ _sortByÂ variable already in the code) to store the current sort order and trigger the notes list provider to re-fetch or re-order notes accordingly. Ensure this sort order preference is persisted (possibly in user settings/local storage) so the app remembers the choice. If manual sorting or custom ordering is desired in future, that could be more complex (involving drag-and-drop reordering of notes in a folder), but initially, implementing the three basic automated sorts (date modified (newest/oldest), title) should suffice. Also, update the UI indicator or menu to reflect the active sort (for example, tick mark next to the active sort option). After implementing, test sorting with various note sets: titles starting with numbers, dates in the past, etc., and ensure it works in conjunction with folder filters and pinned notes (e.g. pinned notes remain at top regardless of sort, if that rule is decided).
2. Quick-Capture (Share Sheet, Widgets, Templates)
* 	â€¢	System Share Extension (iOS & Android):Â Develop a share sheet extension so users can send content into DuruNotes from other apps. OnÂ iOS, this means creating anÂ Action ExtensionÂ orÂ Share ExtensionÂ target in the Xcode project via Flutter (which likely involves some native code or use of theÂ flutter_shareÂ plugin if available). The extension should accept common data types: text snippets, URLs, images, etc. When a user shares to DuruNotes, the extension can create a new note with that content (e.g. if sharing a webpage from Safari, grab the URL and page title into the note; if sharing text, put it in the note body; if an image, add as attachment). Consider adding a default tag or metadata for notes created via share (similar to how email-in notes are taggedÂ #EmailGitHubÂ or web clipsÂ #Web). OnÂ Android, implement an intent-filter to receive shared content. Flutter can handle incoming intents using an external package or through platform channels. Likely, weâ€™ll start an instance of the app (or a headless receiver) that adds the data to a new note. Key micro-tasks: set up the platform-specific code for receiving shares, pass the data to Flutter (maybe via method channel), and implement logic in Dart to save a new note from that data. Also, if the app is locked or requires authentication (if any security in place), decide how to handle that for quick captures (perhaps queue the note until app is unlocked).Â Testing:Â share various content types from different apps (browser, gallery, notes) on both iOS and Android to verify the note is created correctly with the shared content and that no data is lost (e.g. multi-image share, or a URL with no text).
* 	â€¢	Home Screen Widget (Quick Note):Â Provide a widget on mobile platforms for fast note-taking or viewing. ForÂ iOS 16+, Flutter supports widgets via additional packages (since iOS widgets are essentially SwiftUI views, we might need to write a bit of native code or useÂ flutter_widgetkit). The widget could be something simple like a â€œNew Noteâ€ shortcut or a small list of recent notes. A minimal valuable widget might be aÂ Quick AddÂ button: tapping it deep-links into the appâ€™s new-note screen, or even directly opens a text input overlay to capture a note without fully launching the app (this might need iOS App Quick Actions or a widget with a textfield, though interactive widgets on iOS are limited). OnÂ Android, implement an App Widget that could have buttons (New Note, maybe shortcuts to specific folders or recent notes). Android widgets allow some interactivity; for instance, one design is a scrollable list of recent notes and a "+" button. To implement: use Flutterâ€™s widget support (there are packages that simplify this) or write native widget code and have it communicate with Flutter (via App Links or an isolate). Initially, focusing on a simpleÂ "New Note" one-tap widgetÂ might be best. Also considerÂ App ShortcutÂ (long-press app icon to get quick actions like New Note, Search) â€“ on iOS this is done via Info.plist UIApplicationShortcutItems, on Android via manifest shortcuts. These are not home screen widgets but related quick-capture features. Ensure the widget updates appropriately (for example, if showing a count of notes or last note title, it refreshes when notes change â€“ possibly using App Groups on iOS or similar mechanism for shared data).Â Testing:Â add the widget on both platforms, tap it to create notes, and verify it works from various states (app running in background vs closed).
* 	â€¢	Note Templates:Â Introduce templates to speed up capturing structured notes. Templates could be a set of pre-defined note contents (like "Meeting Notes", "To-Do List", etc.) that the user can choose from when creating a new note. A straightforward implementation is to ship a few default template files and allow the user to duplicate them. For example, have a hidden â€œTemplatesâ€ folder with notes that serve as templates, or store template content in a JSON config. Micro-tasks: create a UI in the "new note" flow that lets the user select a template (e.g. aÂ New NoteÂ menu that has a submenu or dialog:Â New Blank Note,Â From Template â†’ [Meeting, Journal, etc]). If using a Templates folder approach, the action would basically duplicate the template noteâ€™s content into a new note. Ensure formatting (checklists, headings, etc.) in the template is preserved. Also allow users to create their own templates eventually â€“ perhaps by saving a note as template (not mandatory in first version, but keep in mind). Implement at least 2-3 useful default templates for now.Â Testing:Â create notes from each template and verify the content matches the template, and that template notes themselves arenâ€™t accidentally shown as normal notes (if using a special folder, maybe hide that folder from normal view or mark templates distinctly).
3. Import/Export Polishing
* 	â€¢	Finalize Evernote ENEX Import:Â Many users migrating will want to import Evernote data, so ensure the .enex import is solid. The UI already offers â€œEvernote Exportâ€ in the import dialogGitHubÂ and callsÂ importService.importEnex(...)Â when an .enex file is chosenGitHub. We need to implementÂ importEnexÂ in the import service if not done: parse the Evernote XML format. Micro-tasks include: using an XML parser to iterate through notes, extracting titles, content (Evernote content is in an ENEX XML, often with their proprietary XHTML format), attachments (resources in ENEX are base64-encoded). Map Evernote content to DuruNotes format â€“ possibly converting ENEX's inline formatting to Markdown or HTML that our editor can render. Also handle Evernote-specific data: tags (ENEX notes haveÂ <tag>Â elements), created and updated timestamps, maybe geolocation (if present, could ignore at first), and note attachments (ENEX resources have data and MIME info). Save each imported note in the database, potentially placing all imported notes into a new folder (maybe a folder named after the ENEX filename or "Imported from Evernote"). If the ENEX represents a single notebook export, perhaps allow the user to choose a target folder or create one automatically.Â Testing:Â use a variety of ENEX files â€“ a small one with a couple of notes, and a large one with hundreds of notes â€“ to ensure performance and correctness. Verify that formatting in Evernote (lists, bold, images, etc.) comes through reasonably. Some fine-tuning might be needed for things like Evernote checkboxes (which come asÂ [ ]Â or a specific ENEXÂ <en-todo>Â tag) to our checklist format. Also ensure that if an import fails for a particular note, it continues with others and reports the error gracefully.
* 	â€¢	Obsidian Vault Import:Â Implement the ability to import a directory of Markdown files (Obsidian or general markdown export). The UI has an option for â€œObsidian Vaultâ€GitHubÂ which triggers a directory picker. We needÂ _processObsidianImportÂ to walk the directory. Micro-tasks: allow the user to pick a folder (already usingÂ FilePicker.getDirectoryPath()GitHub), then scan forÂ .mdÂ files. Preserve the folder structure: for example, if the vault has subfolders, recreate those as DuruNotes folders (or we could import everything into one folder and prepend folder names to titles â€“ but better to actually mirror structure). For each Markdown file, read its content and use the existingÂ importMarkdownÂ logic (which likely already exists for single files). Also import images or attachments: Obsidian vaults often have an "attachments" folder; we should detect images and copy them into our notes as attachments, updating image links in the Markdown to the new location if needed. This can be complex, so initially maybe assume images embedded via relative paths can be handled if we import them alongside notes. If the vault has wiki-style links between notes (e.g.,Â [[Note Title]]), those wonâ€™t resolve in our app unless we implement internal linking; we might leave those as plain text for now or convert them to something identifiable for future.Â Testing:Â take a sample Obsidian vault with a few folders and markdown files (including one with an image embed and one with an wiki link) and run the import. Verify that all files become notes, folder hierarchy is maintained, and content is intact (with basic formatting). If something isnâ€™t supported (like Obsidian front-matter or special syntax), ensure it doesnâ€™t crash the import (we can strip YAML front matter, for example). If performance is an issue on large vaults, consider importing in an isolate or showing progress (the UI already uses a progress dialog for importsGitHub, which we should update as we import many files).
* 	â€¢	Polish Markdown & PDF Export:Â The export functionality is largely implemented with options for Markdown, PDF, and HTMLGitHub. We should refine this to ensureÂ all note contentÂ is exported cleanly. ForÂ Markdown export: verify that special elements like checkboxes, attachments, and tables (if any) are correctly represented. For example, a checklist item should export asÂ - [x]Â orÂ - [ ]Â in Markdown. Images/attachments could be exported as files with references in the Markdown (e.g.,Â ![](attachments/image1.png)Â and in the export folder, an "attachments" subfolder with the actual file). ForÂ PDF export: ensure the PDF generation captures the noteâ€™s rich text styling. Likely we use an HTML-to-PDF or a rendering of the widget to PDF. We may need to embed images in the PDF and apply basic styling (fonts, headings). Check that long notes paginate properly and that PDFs are not enormous in file size (maybe compress images).Â HTML export: ensure that the HTML files include necessary CSS or inline styles so that when opened in a browser the note looks readable. Possibly include a simple stylesheet for things like headings and lists. Micro-tasks also include handling edge cases: what if a note has no title â€“ use first line or "Untitled" as file name for export. If multiple notes exported at once, maybe zip them (currently it appears it exports multiple files individually; perhaps offering a ZIP option could be a nice polish but not strictly necessary if the OS handles multi-file selection). Also test non-English characters and emoji in exports for encoding issues. After polishing, do a test export of a batch of notes that includes various content (text, images, lists, code blocks, etc.) and inspect the output files manually to ensure fidelity.
* 	â€¢	ENEX/Export Metadata & Integrity:Â As a polish step, verify that metadata like created/updated timestamps and tags are handled in import/export. For ENEX import, set the noteâ€™s timestamps to those from Evernote (so original create dates are not lost). For exports, consider optionally including metadata: e.g., for Markdown maybe prepend front matter with create date, tags, etc., or include them in PDF properties. This might be optional or minimal, but at least tags could be output (perhaps as a list at end of MD or a field in HTML). Another polish is to ensureÂ security: if notes are encrypted (the app has an encryption hook in E2.5), exporting should decrypt content before exporting so the output is usable. If encryption is enabled, prompt the user for password if needed to export. Similarly, when importing, decide how to handle if imported data should be immediately encrypted (likely yes if userâ€™s notes DB is encrypted). These details ensure that the import/export feature is production-ready and instills trust that users can get their data in and out reliably.
4. Tasks & Reminders (Checkboxes â†’ Tasks, Agenda & Alerts)
* 	â€¢	Checkbox â†’ Task Conversion:Â Extend the existing checklist feature to formally support tasks. The editor already allows inserting checkboxes (as part of the formatting toolbar, which is done in Editor V2). We need to give those checkboxes additional behavior/state, turning them into tasks. At a basic level, every checklist item can be considered a â€œtaskâ€ with a completion status (checked = done). To enrich this, we can allow each task to have metadata like aÂ due dateÂ orÂ priority. Implementation could be done in a few ways: one approach is to detect special syntax in the note text (for example, appendingÂ (@due 2023-12-01)Â to a line could indicate a due date) â€“ but thatâ€™s not very user-friendly. Better is a UI approach: when the user focuses or long-presses a checkbox line, show options to â€œAdd Reminder/Dateâ€ or â€œConvert to Taskâ€ which opens a date-picker and maybe a small form for due date and an optional reminder alarm. Under the hood, we might store these in a separate tasks table linking back to the note and checklist line (to avoid altering the note text to store metadata). Alternatively, we could embed a hidden marker in the note text (like an inline HTML comment or a special character) to identify the due date â€“ but thatâ€™s hacky. A cleaner approach: maintain a mapping of note ID + line index to a task object (with due date, etc.) in the database. Micro-tasks: design the data model for tasks (could simply reuse note ID, text snippet, a bool done, a DateTime for due, maybe a string for reminder time or recurrence if later). Provide the UI to set a due date on a task â€“ e.g., tapping an â€œAdd reminderâ€ icon on a checklist item triggers a date-time picker. Once set, visually indicate it in the note (could append a small calendar icon and date next to the checkbox line in the UI). Also, ensure that when a checkbox is checked off, if it had a due date, we mark the task completed (possibly store completion timestamp if needed). If a user unchecks it, mark as not done again. This essentially ties the noteâ€™s content to a lightweight task management system.
* 	â€¢	Task List & Calendar View:Â Create dedicated views to manage tasks across all notes. Many users will want to see a summary of all their to-dos without hunting through notes. Implement aÂ Task List screenÂ that aggregates all open (incomplete) tasks from every note. Each entry can display the task description (the text of the checklist line), maybe the note title it belongs to (for context), and the due date if any. Users should be able to check-off tasks right from this list (which should also update the note). Group tasks by date (e.g. overdue, due today, tomorrow, later, or no date). For a calendar view, consider a monthly calendar that highlights days with tasks due. Selecting a date shows tasks due that day. This could be a separateÂ Calendar tabÂ or integrated into the task list with a calendar widget at top. Micro-tasks: implement a provider or query that collects all tasks (note ID, text, due date, done status) from the notes database. If tasks are stored as separate records, thatâ€™s straightforward. If not, we might scan notes for checklist syntax â€“ but thatâ€™s inefficient; better to store tasks explicitly when added. Build theÂ UI for the Task List: maybe aÂ TaskListScreenÂ with sections â€œOverdueâ€, â€œTodayâ€, â€œUpcomingâ€, etc. For each task, show a checkbox and label, and perhaps a small link or button to open the parent note (so user can jump to full note context). Also implement theÂ Calendar: possibly use a Flutter calendar widget or just a grid of days; show markers on days that have tasks. The user can tap a day to filter tasks by that date. Ensure the task list updates in real-time as tasks are completed or added (Riverpod providers can help here, e.g., invalidate the task provider on changes).Â Testing:Â create several tasks with various due dates, then check the task list and calendar â€“ verify tasks appear in correct sections and dates. Mark some done via the task list and ensure they get checked off in the original note and disappear from "open tasks" view (maybe move to a â€œCompletedâ€ section if we show that or simply remove). Also test tasks with no due date â€“ they might appear in a "No date" or "Someday" section.
* 	â€¢	Reminders & Notifications:Â Enable optional notifications for tasks with due dates. Users should be reminded when a task is coming due. Implement local notifications on each platform: onÂ iOS, useÂ flutter_local_notificationsÂ or native APIs to schedule a notification at the specified time; onÂ Android, do similarly. Micro-tasks: when a user sets a due date/time on a task and toggles a â€œRemind meâ€ option, schedule a notification for that datetime. The notification could say â€œReminder: [Task text] in [Note Title]â€. Tapping it could deep-link into the app, opening that note or the task list. Also consider a daily summary notification if many tasks due on a day (optional enhancement). We must handle timezone properly and device reboots (on Android, reschedule notifications after reboot via a BroadcastReceiver, perhaps the plugin handles it). Additionally, provide a way to see and manage reminders â€“ e.g., a â€œNotificationsâ€ or simply by editing the task to remove the reminder if needed. Ensure that completing a task cancels its pending notification (so you donâ€™t get reminded for something already done).Â Testing:Â schedule a reminder for a task in the next minute or two to see that a notification fires on both iOS and Android (handling permission prompts on iOS the first time). Test that tapping the notification opens the app to the relevant screen. Also test that if you mark the task done before the time, the notification is canceled.
* 	â€¢	Integration with External Calendars (future consideration):Â Not strictly needed for initial implementation, but design with the possibility in mind. For example, maybe later allow exporting tasks with due dates to an iCal feed or syncing with Google Calendar or Apple Reminders. For now, ensure our data model could accommodate an ID or link if we ever integrate with such services. This is just a note to keep the architecture flexible.
* 	â€¢	Usability & UX:Â Make sure that adding tasks doesnâ€™t disrupt the simplicity of note-taking. The UI for due dates and reminders should be discoverable but not intrusive. Perhaps show a smallÂ calendar iconÂ on a checklist line â€“ tapping it opens date picker. If no due date, icon could be hollow; if there is one, show filled icon or date text. Also, possibly highlight overdue tasks in the note (e.g., date in red) as visual cues. Another UX consideration: if a note is purely a task list, maybe allow converting it to a â€œtask noteâ€ with a summary of how many tasks open, etc., but that's extra polish.Â Testing UX:Â have someone use the feature to add tasks, see if they understand how to set a reminder, and adjust as needed (maybe tooltips or a brief tutorial overlay when first using tasks).
5. Handwriting & Drawing Support
* 	â€¢	Drawing Canvas Integration:Â Add the ability to create handwritten notes or sketches. This is especially important for tablet users (iPad with Apple Pencil, Android tablets with stylus) but should work with finger drawing on phones too. We will implement aÂ canvas widgetÂ where users can draw. Micro-tasks: choose a Flutter drawing library or useÂ CustomPainterÂ to capture touch input. There are Flutter packages likeÂ signatureÂ (for simple pen input) or more advanced ones for sketching. We need to support multiple strokes, maybe different pen colors or sizes (initially even one pen is fine). Create a new UI flow: e.g., in the note editor toolbar, add aÂ â€œDrawâ€Â icon. Tapping it could open a full-screen drawing modal on top of the note. The user draws with finger or stylus; provide basic controls like pen, eraser, undo (support at least one-level undo by removing last stroke). When done, the drawing is saved as an image and inserted into the note content (for example, as an image attachment). The noteâ€™s format might treat it like an attached image that is displayed inline. For storage, save the drawing as a PNG (or SVG if vector, but raster is simpler) in the appâ€™s storage and link it to the note (possibly uploaded to the backend if syncing). We should also consider performance: large canvases or many strokes could be heavy; perhaps limit the drawing area size to screen dimensions or slightly above, and scale the image if needed.Â Testing:Â on a phone and tablet, open a note, create a drawing, ensure the image appears in the note and is saved. Reopen the note to verify the image persists. Try multiple drawings in one note (two images). Also test memory usage by drawing a large detailed sketch â€“ ensure it doesnâ€™t crash and that image file size is reasonable (maybe compress if too big).
* 	â€¢	Stylus and Platform-Specific Enhancements:Â Make sure to leverage platform capabilities where possible. OnÂ iPadOS, detect Apple Pencil vs finger (Appleâ€™s API can differentiate pointer type, though Flutter might not expose that easily â€“ but some plugins might). Perhaps disable finger touch when Pencil is in use to avoid stray marks (palm rejection). On Android, if a stylus is used, ensure that the input is handled (some devices have specific stylus APIs, but generally touch events should cover it). At minimum, test with an Apple Pencil on iPad and an S-Pen on a Samsung device if available. Ensure latency is low and drawing feels smooth (use Flutterâ€™sÂ GestureDetectorÂ withÂ onPanUpdateÂ for real-time strokes, or a dedicated canvas widget). If performance is laggy, consider using a lower-level approach or simplifying (e.g., not too high resolution). Another iOS-specific idea: Apple providesÂ PencilKitÂ for a full-featured drawing experience (with tools palette), but integrating that with Flutter might require a custom platform view. This could be a later improvement; initially, a custom Flutter canvas will do.
* 	â€¢	Handwriting Recognition (Future):Â While the immediate goal is to allow drawing and handwriting as images, consider future OCR or searchable handwriting. Apple PencilKit on iPad has scribble text recognition (if you write in a TextField it becomes text), and Apple Notes can search handwritten text. Our first version likely wonâ€™t have this. But we might plan an enhancement where an on-device ML model (or Appleâ€™s Vision framework) scans the saved drawing and extracts text for search indexing. Mark this as a future premium feature perhaps. For now, keep the drawings as non-searchable attachments.
* 	â€¢	UI Integration:Â Once a drawing is inserted, the note should show it just like an image. Users can tap it to view or edit. Editing a drawing is trickier â€“ weâ€™d need to either save the vector data of strokes to allow re-editing. If we save only a PNG, re-editing means starting a new drawing. A better approach is to save strokes (maybe as a list of points or a SVG path) alongside the image. If time permits, we can store the raw drawing data (perhaps in a simple JSON or as part of aÂ .pngÂ metadata) so that tapping the image can reopen the drawing canvas with the existing drawing for further editing. This is an advanced capability; if itâ€™s too much, document that drawings are not editable once saved (or only append possible).Â Testing:Â check the entire flow on different screen sizes. On phones, the canvas might need UI to zoom or pan if note is larger than screen â€“ but initial implementation can just fit screen and no zoom. On tablets, the canvas can be larger; test drawing to corners. Also ensure that using the drawing feature doesnâ€™t break anything in notes sync or formatting (e.g., if note content is encrypted, the image should be encrypted too if thatâ€™s how attachments are handled).
* 	â€¢	Cross-Platform Release Considerations:Â When releasing the drawing feature, highlight that it works best on tablets with stylus but is available on all devices. Make sure to update any user guides or onboarding to mention the new capability (if applicable).
6. On-Device AI Features (Semantic Search, Auto-Tags, Summaries)
Note: These AI features will be marked as premium and may be introduced gradually. Weâ€™ll ensure the groundwork (like data structures and placeholders) is laid early, even if the heavy model integration comes later.
* 	â€¢	Semantic Search Implementation:Â Enhance the search function to find notes by meaning, not just exact keyword matches. This involves using a text embedding model to represent notes and queries in a vector space. On-device approach means we need a lightweight model (for example, MiniLM or SBERT distilled models) possibly via a TensorFlow Lite or CoreML file. Micro-tasks: Research availableÂ embedding modelsÂ that can run on mobile within reasonable memory/CPU (perhaps a 20-50MB model). Set up a pipeline so that when a note is created or edited, we compute its embedding and store it (maybe in a new table or even as a vector in memory â€“ though storing high-dim vectors in SQLite is possible but could bloat; might use a separate local database or a pre-built vector search library). Alternatively, since notes are not extremely many (assuming), we could compute similarity on the fly by embedding all notes at search time, but that could be slow for large data. Better to pre-compute and update incrementally. Implement a search function that given a query, computes the query embedding and finds top N nearest-note embeddings (using cosine similarity or Euclidean distance). There are Flutter plugins or Dart libraries for vector math, but possibly we will write our own small function if needed. Because this is on-device, ensure it runs in a background isolate to not jank the UI. Also provide a UI indicator or option: perhaps semantic search is always on (merging results with normal search) or thereâ€™s a toggle "Semantic Search". A possible strategy: perform normal keyword search, and if it yields few results or user selects a toggle, then show semantic matches (â€œYou might be looking for these notesâ€¦â€).Â Testing:Â try searching with terms that donâ€™t exactly appear in notes but are related to note content (e.g. note contains â€œflight bookingâ€ and search query is â€œairplane reservationâ€) and see if semantic search brings it up. Compare with known expected results to fine-tune the model or approach. Test the performance on a mid-range device to ensure itâ€™s under, say, 500ms for a query on average note corpus (if not, consider optimizing or using a smaller model). Also test that this works offline (no network calls).
* 	â€¢	Auto-Tagging Notes:Â Use AI to suggest or assign tags to notes based on content. Once the tag system (from Organization features) is in place, we can automate tagging for user convenience. Micro-tasks: for each note, run a lightweight classification or keyword extraction. This could be done with a simple approach initially: e.g., take the most frequent significant words in the note that arenâ€™t common stopwords, and suggest them as tags (especially proper nouns or unusual terms). For a more AI-driven approach, a model like GPT (if on-device or via API) can summarize keywords, but on-device GPT is not feasible yet. Perhaps use a smaller NLP model or even a hardcoded dictionary of topics. Another idea is to integrate with platform ML (for example, iOS has NLP libraries or Android has ML Kit for entity extraction). Given the time, a rule-based or TF-IDF approach might suffice for MVP. Implementation: whenever a note is saved or updated, if auto-tagging is enabled (and user is premium), compute tag suggestions. If we want to auto-assign, we could automatically add those tags to the noteâ€™s tag list, marking them as AI-generated (maybe with a distinct color or icon). Alternatively, show suggestions to the user somewhere (like a chip that says â€œAdd tag: Travelâ€ that the user can tap to confirm). For now, auto-assign might be acceptable to simplify. Make sure we donâ€™t overwhelm with too many tags â€“ limit to e.g. top 3 suggestions per note.Â Testing:Â try notes of different topics (â€œProject meeting notesâ€, â€œGrocery listâ€, â€œTravel itineraryâ€) and see if the auto-tags make sense (e.g., #Meeting, #Shopping, #Travel). Ensure that tags are consistent (if one note says â€œProject Apolloâ€, auto-tag might suggest â€œApolloâ€ â€“ if multiple notes have that, good to have same tag). Also ensure we donâ€™t duplicate existing tags (if a user already tagged a note, avoid adding the same tag again).
* 	â€¢	AI Summaries of Notes:Â Provide a one-click way to get a summary of a long noteâ€™s content. This could be useful for quickly recalling what a note is about. However, doing NLP summarization on-device is heavy. Options: a smaller T5 model or similar could maybe run, but likely still too slow on mobile for large text. We might start by implementing this as a cloud service (if allowed) or as a premium feature that requires internet â€“ but the plan says on-device AI, so perhaps look into any available summarization model that can be distilled. Alternatively, an approximate summarization: take the first N lines or the headings of the note to generate a pseudo-summary. For initial implementation, we could use a heuristic: for example, if the note has multiple paragraphs, take the first sentence of each of the first few paragraphs as a "summary preview". Mark it clearly as an auto-generated snippet. Or, use an extractive approach: pick out sentences containing keywords (this can be done by scoring sentences with TF-IDF against the whole note). Micro-tasks: implement a functionÂ summarizeNote(text) -> summaryÂ using either a simple heuristic or attempt to integrate an ML model (if we find a small one pre-trained for summarization). Provide a UI to display the summary â€“ maybe on the note view, a collapsible â€œAI Summaryâ€ section at the top that, when tapped, shows the summary. Or in the notes list, show a one-line summary under the title for long notes (like a preview, which we might already have as first line; but an AI summary might be more coherent). If heavy to compute, do it on-demand: e.g., user taps â€œSummarizeâ€ button and we then compute and show it (with a loading indicator).Â Testing:Â take a very long note and use the feature, check if the summary is reasonably accurate. Since the quality might not be perfect, consider labeling it â€œSummary (Beta)â€ or allow the user to refine if needed. Also ensure for shorter notes the summary doesnâ€™t just repeat the content (maybe disable or trivialize if note is < certain length).
* 	â€¢	Performance & Privacy:Â All these AI features should respect the device resources and user privacy. On-device means data stays local, which is good, but also means we need to manage memory (embedding models and possibly others loaded into RAM). We may want to lazily load models (only load the embedding model when user triggers a semantic search, and maybe unload after). For auto-tagging and summary, if they are not frequently used or heavy, consider requiring the user to initiate (or do them in small background tasks when device is idle). Provide a setting toggle for â€œIntelligent featuresâ€ so power users can turn it off if they worry about battery or performance. Also, test on older devices if possible to gauge impact. Possibly restrict on-device AI to relatively modern devices or to users who opt-in (and communicate in release notes that these features might use significant resources).
* 	â€¢	Integration & Premium Gating:Â Tie these AI features into the premium system from the start. For example, wrap the UI for â€œSemantic Searchâ€ or â€œAuto-tagâ€ with the Premium gate widget (so free users might see it disabled or see a prompt to upgrade). The code already has aÂ PremiumGateWidgetÂ that shows an upgrade prompt if the user doesnâ€™t have accessGitHubGitHub. Use this to quickly enforce the gating once we add the feature. This way we donâ€™t have to retrofit later. For testing, we can temporarily mark ourselves as premium to use the features. Ensure that gating is done at appropriate granularity (e.g., maybe semantic search and summaries are premium, but basic search is free; auto-tagging could be premium or could be free to encourage tag usage â€“ product decision needed).
7. Secure Sharing (Password-Protected Notes)
* 	â€¢	Secure Share Link Generation:Â Enable users to share a note via a secure link that can be opened in a web browser with a password. This requires backend support or at least a cloud function, since the content must be accessible outside the app. If we useÂ SupabaseÂ (mentioned in code), we could leverage its functions or storage. One approach: when a user enables secure sharing for a note, we generate a unique share ID and anÂ encryption keyÂ derived from the user-provided password. We then encrypt the noteâ€™s content (and attachments) with that key and upload it to a secure storage (e.g., Supabase Storage bucket or a table). The link would be something likeÂ https://duru.notes/share/<ID>. When someone accesses that, they get a page that asks for the password, then decrypts and shows the note. Micro-tasks: Build a cloud function or simple Node/Denoserver (maybe Supabase Edge Function) that serves the share page. Alternatively, create a very simple static HTML + JS page that can fetch the encrypted note via Supabase REST and decrypt client-side (to avoid having to host a full server). This might be complex to implement fully right now, so perhaps as a first iteration, the app itself could handle sharing by generating aÂ password-protected PDFÂ or anÂ encrypted fileÂ to send. However, the feature explicitly says â€œlinksâ€, implying an online solution. So focusing on that: implement an API route or functionÂ getSharedNote(id)Â which returns the encrypted note blob. The front-end (a lightweight webpage) can use WebCrypto to decrypt after the user enters password. Weâ€™ll need to include the decryption script in the page. If building a quick solution, even a small Next.js or Express app on Vercel could do (but using the existing infrastructure is preferable). Make sure the ID is sufficiently random (use UUID or similar) so itâ€™s unguessable.
* 	â€¢	In-App UI for Sharing with Password:Â Create a UI flow in the app: for example, in the note options, add â€œShare Securelyâ€. When selected, if the note is not yet shared, prompt the user to set a password (allowing an optional hint maybe). Once they confirm, call the backend to create the share entry. On success, the app should receive the share link (URL) and display it to the user with options to copy or share via other apps. If the note was already securely shared (i.e., link exists), the option could instead show â€œManage Secure Shareâ€ where the user can disable it (revoke link) or copy the link again. Micro-tasks: design a small dialog or screen for this. On enabling, generate password (or use user input), perform encryption of content on the device (probably using a library for AES encryption with the password as key) before upload for zero-knowledge sharing â€“ this is a plus for security, but even if we trust the server, encrypting client-side is ideal for true E2EE. If time is short, we might skip client encryption and rely on password check server-side, but thatâ€™s less secure (server could see content). Assuming we try client-side: get note content, attachments; serialize them (maybe as HTML or markdown) into a single package (could use JSON containing note fields and attachments base64). Encrypt that with AES. Send that to backend along with a hash of password (to verify later). Store it keyed by the share ID. The backend should not store the actual password, only a hash for verification if we want server-side check, but if doing client-side decrypt, backend doesn't even need the password hash, only the encrypted blob. The front-end page will just retrieve the blob and attempt decryption with whatever password user enters â€“ if wrong, content will be gibberish (we can detect a failure maybe by a known header bytes after decrypt). For attachments, maybe include them in the encrypted blob, or host them separately but also encrypted with same key.
* 	â€¢	Shared Note Viewing Page:Â Develop the simple web page that will allow viewing the note. This page can be very minimal, just enough to display the note content with basic formatting. If we have the note content in HTML already (maybe easiest is to export the note as HTML for sharing), we can store that. The page upon password entry decrypts the data and injects the HTML into the page. If attachments (images) are included, an easy way is to inline images as data URIs in the HTML before encryption (so one blob has everything). A more sophisticated way is to have separate endpoints for attachments, but that complicates the process. For now, bundling into one might be fine for moderate note sizes. Also, ensure the page is mobile-friendly (since someone might open the link on a phone without the app). We might host this page either on our website or use something like GitHub Pages or Supabase Edge Functions that return HTML.Â Testing:Â after implementing, try sharing a note to yourself: generate link, open in an incognito browser, enter the password, verify the note appears correctly including images or formatting. Check that an incorrect password doesnâ€™t show content (maybe the page just says â€œWrong password, try againâ€). Also test revocation: after you â€œstop sharingâ€ a note (which would delete the entry on server), the link should no longer fetch content (page should show an error or note not found).
* 	â€¢	Revocation & Management:Â Provide a way to disable a shared link. In the app, maybe the â€œShare Securelyâ€ button toggles to â€œDisable Secure Shareâ€ if a link is active. Implement that by removing the stored content from backend and invalidating the ID (perhaps keep a list of revoked IDs server-side to prevent reuse, or just delete it). If someone tries an old link, they should get a message like â€œThis note is no longer available.â€ Optionally, allow the user to regenerate a new link (which would create a new ID and require a new password) â€“ for example, if they suspect the password was compromised but still want to share the note, they can regen. Not mandatory for first version, but keep it in mind (e.g., simply disable and enable again would naturally make a new link if we always generate fresh). Audit-wise, might not need heavy tracking, but maybe log that a note was shared for the user (maybe an icon on the note in the list indicating it's shared? Nice touch: a tiny link icon in note list or detail view if active).
* 	â€¢	Security Considerations:Â Use strong encryption (AES-256-GCM or similar) if doing client-side encryption. Make sure to derive the key from password properly (PBKDF2 or Argon2 with salt). The salt could be stored openly with the blob. Also,Â do notÂ include the password in any URL or client-side code obviously. The user must manually provide it. Encourage the user to share the password out-of-band (since sharing link and password together nullifies the security). Perhaps add a note in the UI: â€œShare the link and password separately for security.â€ If storing on backend without encryption, ensure at least password verification is required (so the backend wonâ€™t serve content until correct password given - but that means backend has to know the password or its hash, which is less ideal privacy-wise). Given we value privacy (notes are likely end-to-end encrypted in app), leaning toward full E2EE for share links is better even if itâ€™s a bit complex. Also ensure that if notes themselves are encrypted in our database, we use the decrypted content for sharing (since we have it in app memory when user initiates share).
* 	â€¢	Premium Tie-in:Â Secure sharing might be a candidate for a Premium feature as itâ€™s more enterprise/power-user oriented. We can use the premium gating so that free users see this feature locked. However, we might also consider allowing maybe a basic sharing for free and advanced (with password) for paid â€“ depends on strategy. For now, since the item is â€œSecure Sharingâ€, likely itâ€™s intended as a premium-only addition. Implement the gating accordingly (wrap the Share Securely option or the entire flow in a premium check, so non-premium clicking it either shows paywall or a message).
8. Paywall Scaffolding (Premium Feature Gating)
* 	â€¢	Introduce Feature Flags for Premium:Â To prepare for a future monetization (without yet collecting payments), we will integrate flags in the code to designate certain features asÂ Premium. This ensures that when the time comes to launch the paywall, we can simply flip a switch or prompt users to subscribe, rather than refactoring features. The repository already contains aÂ PremiumGateWidgetÂ and subscription service stub, indicating some groundwork is doneGitHub. We should extend this: define a list or enum of premium features (e.g., PremiumFeature.autoTag, PremiumFeature.secureShare, etc.). In the code paths of those features, use the Premium gate logic to restrict access. For example, wrap UI elements: if user is free, either hide the button or show it with a lock icon. The PremiumGateWidget can show an upgrade prompt which is useful in some places (e.g., if a free user tries to use AI search, we could show the dialog telling them itâ€™s premium). Micro-task: Audit each feature in this plan and decide its access level. For now, likelyÂ On-Device AI,Â Secure Sharing, and perhapsÂ advanced Export optionsÂ might be premium. Also possiblyÂ larger storage or number of devicesÂ etc., but thatâ€™s beyond this scope. Implement checks accordingly. For instance, when user triggers a semantic search, callÂ PremiumGateWidget(featureName: "Semantic Search", child: ActualSearchWidget)Â so that it automatically either shows the search results or an upgrade UIGitHubGitHub. Similarly for secure sharing flow â€“ before generating a link, confirm premium.
* 	â€¢	Maintain Free/Premium Balance:Â We need to ensure core note-taking remains free so as not to turn off users. So features like basic search, syncing, note editing, etc., are free. Premium gates will only be around theÂ newÂ power features (AI stuff, secure share, possibly large storage or future features). When implementing gating, make sure that free users donâ€™t accidentally lose existing functionality. For example, if some form of search existed and now we add semantic search, the free user should still get the normal search seamlessly, just not the AI enhancements. That implies our code might have branches: e.g.,Â if (premium) useSemanticSearch else useKeywordSearch. Same for tags: auto-tag could be premium, but manual tagging stays free; ensure the UI distinguishes an â€œAuto-tagâ€ button thatâ€™s locked vs the normal tag UI. For tasks, we likely keep that free (since itâ€™s core productivity). PerhapsÂ Secure sharing and AIÂ are the main premium draws at this point. Handwriting might be free (most note apps provide drawing free), unless we think of it as special â€“ but probably free.
* 	â€¢	Subscription Service and Paywall Screen:Â Even though we are not fully implementing payments yet, itâ€™s good to stub out the flow. The PremiumGateWidget has anÂ _showPaywall()Â method that callsÂ subscriptionService.presentPaywall(...)GitHub. We can implement a basic paywall screen that lists benefits and has dummy purchase buttons (or if we plan to integrate with RevenueCat or StoreKit later, put placeholder there). For now, the paywall could simply always â€œsucceedâ€ for testing (like a secret way to mark user as premium without payment, perhaps tapping a hidden button 5 times or using a debug menu to simulate purchase). We might use aÂ premiumAccessProviderÂ that currently just reads a local flag or config. Micro-task: Set up a way to toggle premium status in dev builds (maybe if user email is a certain test email or simply a debug switch in settings like "Enable Premium for testing"). This helps testing gated features before payments are in place.
* 	â€¢	Cross-Platform Purchase Considerations (later):Â Note that onÂ iOS, in-app purchases for subscriptions will need StoreKit integration; onÂ Android, the Play Billing. Weâ€™re not doing that now, but keep code organized so adding it isnâ€™t hard (e.g., the subscriptionService can later implement platform-specific purchase calls). Possibly use an existing Flutter plugin when time comes. For now, focus on gating logic and UI. Also consider how to handle if user has premium on one device â€“ likely the premium status is tied to their account (maybe via Supabase Auth user metadata). So when toggling premium for testing, perhaps simulate it at account level (e.g., a flag in Supabase user table likeÂ is_premium). We could even wire theÂ premiumAccessProviderÂ to read from a remote config or user profile. That way, if a user logs in on another device, the app knows theyâ€™re premium. A simple approach now: have the app check a certain field in the user record on startup (the Supabase auth user metadata might have aÂ subscriptionStatus). If thatâ€™s not easily available, we can just keep it local until real purchases are integrated.
* 	â€¢	UI/UX for Locked Features:Â Make sure the user experience for encountering a locked feature is friendly and enticing, not frustrating. The PremiumGateWidget currently shows a nice prompt with an upgrade buttonGitHubGitHub. We should use this in places where the user might click on something locked. Additionally, consider adding subtle indicators in the UI that something is premium: e.g., a lock icon on a button or a tooltip â€œPremiumâ€. This prevents confusion (so the user knows why they canâ€™t use it until they upgrade). But avoid littering the interface with locks â€“ focus on when they actually try to use it. Fine-tune the messaging: e.g., â€œThis feature requires a Premium subscriptionâ€ and maybe list one or two benefits. Since actual purchase flow isnâ€™t live, the Upgrade button might just enable premium in debug or show a â€œComing soonâ€ message. We can implement it to callÂ presentPaywall()Â which in turn could just set premium true for now (for testing).
* 	â€¢	Testing Gating:Â Simulate a non-premium user and verify that all premium features are indeed inaccessible: AI search returns maybe basic results or a prompt, secure share option shows an upgrade dialog, etc. Then simulate premium (toggle the flag) and ensure those features become available and work. Itâ€™s important no premium feature is accidentally giving free access due to a missed check, and conversely that no free feature got locked by mistake. This requires careful review of the gating conditions once implemented.
Cross-Platform Deployment Considerations
* 	â€¢	Mobile (iOS & Android) First:Â The immediate development will target phone form-factors. We should test on both platforms frequently as we implement each feature (since subtle differences can arise, e.g., handling file access in import on Android vs iOS). Given the tight timeline (â€œdeadline ASAPâ€), focus on getting features working on mobile devices where most users are. Ensure to use adaptive layouts or Flutterâ€™s responsive design so that scaling up to tablet and desktop is smooth.
* 	â€¢	Tablet UI Adjustments:Â Once the features are working on phones, allocate time to optimize for tablets (iPad and Android tablets). This may involve using split view layouts in some places. For instance, on a tablet, the folders/tags pane could be a left sidebar rather than a dropdown, showing both the list of notes and note content side by side. The drawing feature on tablets might utilize the full screen with perhaps toolbars on the side (taking cues from native tablet apps). Widgets on tablets might need different default sizes. Test all new UIs in tablet orientation (both portrait and landscape). Some platform specifics: on iPad, consider adding support for multi-tasking (Split View/Slide Over) and pencil interactions; on Android tablets/ChromeOS, test window resizing. Also, theÂ keyboard shortcutsÂ (thereâ€™s a fileÂ keyboard_shortcuts_handler.dartÂ in the repo) could be extended for iPad keyboards or Mac, e.g., using the hardware keys to trigger actions (like Cmd+N new note, etc.). This might not be critical for this phase but is a nice enhancement for tablet/desktop later.
* 	â€¢	Desktop (macOS & Windows) Launch:Â After mobile/tablet are solid, prepare the desktop apps. Flutter makes it relatively easy to build for desktop, but we should spend time on polish: for example, ensuring that menus or dialogs look native on desktop, enabling drag-and-drop of files into the app (maybe a user might drag a PDF into a note on desktop â€“ could be a bonus feature to consider when polishing import). Also, file system access is more direct on desktop, so import/export dialogs might use system file pickers (the code already usesÂ FilePicker, which should adapt to desktop). TestÂ notificationsÂ on desktop if we implement them for tasks â€“ on macOS, local notifications should work via Notification Center; on Windows, via Action Center. Some desktop-specific adjustments: window management (make sure the app window can be resized down to a small size gracefully, or perhaps set a minimum size so layouts donâ€™t break). If we have a menu bar or tray icon (likely not for now), consider if needed for quick capture on desktop (maybe not needed yet). Ensure the app icon and name are set up for desktop builds, and codesigning if needed for distribution (not urgent until release).
* 	â€¢	Testing & QA Across Platforms:Â Given the short timeline and intense development (18h/day), itâ€™s crucial to continuously test each feature on at least one device per platform. Set up a checklist (similar to the saved searches QA) for each major feature and cross off on iOS and Android. Later, do a pass on macOS and Windows. If time allows, recruit a colleague or use TestFlight/Play Beta to get early feedback on these features in case there are device-specific bugs (camera, stylus, etc.). Since we are integrating many new capabilities back-to-back, watch out for stability and performance regressions â€“ e.g., memory usage with big imports or long sessions. Use Flutterâ€™s dev tools to monitor for memory leaks (especially with drawing and AI models in memory). Itâ€™s better to catch issues early than have them pile up near the end.
By following this plan, we address immediate user needs (better organization and capture), intermediate enhancements (tasks, import/export refinement), and advanced differentiators (AI features, secure sharing), all while laying the groundwork for a sustainable business model (premium subscriptions). Each feature has been broken into actionable tasks to guide development.Â Staying organized and testing each part thoroughly will be keyÂ to delivering this ambitious set of updates in a rapid timeframe. Good luck, and happy coding!Â 
GitHub
GitHub
Â (These references confirm that foundational elements like folder loading and saved-search chips are already present, guiding our implementation steps.)
