-- Phase 3: Production-Grade PostgreSQL Optimizations for Duru Notes
-- This migration optimizes the remote Supabase PostgreSQL database
-- for better performance with encrypted data and real-time sync

-- ============================================
-- 1. CONNECTION AND MEMORY OPTIMIZATION
-- ============================================
-- Note: These settings might require Supabase Pro plan or custom config
-- ALTER SYSTEM SET shared_buffers = '256MB';
-- ALTER SYSTEM SET effective_cache_size = '1GB';
-- ALTER SYSTEM SET work_mem = '16MB';
-- ALTER SYSTEM SET maintenance_work_mem = '64MB';

-- ============================================
-- 2. PERFORMANCE INDEXES FOR ENCRYPTED DATA
-- ============================================

-- Hash index for encrypted title equality searches (faster than btree for equality)
CREATE INDEX IF NOT EXISTS idx_notes_title_enc_hash
ON notes USING hash(title_enc)
WHERE deleted = false;

-- Composite index for user-based queries with sorting
CREATE INDEX IF NOT EXISTS idx_notes_user_updated_deleted
ON notes (user_id, updated_at DESC)
WHERE deleted = false;

-- Index for user with pinning support (if is_pinned column exists)
-- CREATE INDEX IF NOT EXISTS idx_notes_user_pinned_updated
-- ON notes (user_id, is_pinned DESC, updated_at DESC)
-- WHERE deleted = false;

-- Index for sync operations - finding changes since timestamp
CREATE INDEX IF NOT EXISTS idx_notes_user_updated_sync
ON notes (user_id, updated_at)
WHERE updated_at IS NOT NULL;

-- GIN index for JSONB metadata searches (if metadata column exists)
-- CREATE INDEX IF NOT EXISTS idx_notes_metadata_gin
-- ON notes USING gin(metadata)
-- WHERE metadata IS NOT NULL;

-- ============================================
-- 3. FOLDER OPTIMIZATION INDEXES
-- ============================================

-- Index for folder hierarchy navigation
CREATE INDEX IF NOT EXISTS idx_folders_user_parent
ON folders (user_id, parent_id, sort_order)
WHERE deleted = false;

-- Index for folder path lookups
CREATE INDEX IF NOT EXISTS idx_folders_user_path
ON folders (user_id, path)
WHERE deleted = false;

-- Index for sync operations on folders
CREATE INDEX IF NOT EXISTS idx_folders_user_updated_sync
ON folders (user_id, updated_at)
WHERE updated_at IS NOT NULL;

-- ============================================
-- 4. NOTE-FOLDER RELATIONSHIP INDEXES
-- ============================================

-- Index for finding notes in a folder
CREATE INDEX IF NOT EXISTS idx_note_folders_folder_note
ON note_folders (folder_id, note_id);

-- Index for finding a note's folder
CREATE INDEX IF NOT EXISTS idx_note_folders_note_folder
ON note_folders (note_id, folder_id);

-- Index for user-based queries
CREATE INDEX IF NOT EXISTS idx_note_folders_user
ON note_folders (user_id);

-- ============================================
-- 5. CLIPPER INBOX OPTIMIZATION
-- ============================================

CREATE INDEX IF NOT EXISTS idx_clipper_inbox_user_created
ON clipper_inbox (user_id, created_at DESC)
WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_clipper_inbox_user_unread
ON clipper_inbox (user_id, is_read)
WHERE is_read = false AND deleted = false;

-- ============================================
-- 6. TASK MANAGEMENT INDEXES
-- ============================================

-- Index for finding tasks by note
CREATE INDEX IF NOT EXISTS idx_note_tasks_note_status
ON note_tasks (note_id, status)
WHERE deleted = false;

-- Index for finding open tasks with due dates
CREATE INDEX IF NOT EXISTS idx_note_tasks_user_due
ON note_tasks (user_id, due_date ASC)
WHERE status = 'open' AND deleted = false AND due_date IS NOT NULL;

-- Index for sync operations on tasks
CREATE INDEX IF NOT EXISTS idx_note_tasks_user_updated
ON note_tasks (user_id, updated_at)
WHERE updated_at IS NOT NULL;

-- ============================================
-- 7. TEMPLATE OPTIMIZATION
-- ============================================

CREATE INDEX IF NOT EXISTS idx_templates_user_category
ON templates (user_id, category, usage_count DESC)
WHERE deleted = false;

CREATE INDEX IF NOT EXISTS idx_templates_user_system
ON templates (user_id, is_system, sort_order)
WHERE deleted = false;

-- ============================================
-- 8. OPTIMIZED RLS POLICIES
-- ============================================

-- Drop and recreate policies with better performance
-- Notes table
DROP POLICY IF EXISTS "Users can view own notes" ON notes;
CREATE POLICY "Users can view own notes" ON notes
    FOR SELECT TO authenticated
    USING (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can insert own notes" ON notes;
CREATE POLICY "Users can insert own notes" ON notes
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can update own notes" ON notes;
CREATE POLICY "Users can update own notes" ON notes
    FOR UPDATE TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can delete own notes" ON notes;
CREATE POLICY "Users can delete own notes" ON notes
    FOR DELETE TO authenticated
    USING (user_id = auth.uid());

-- Folders table
DROP POLICY IF EXISTS "Users can view own folders" ON folders;
CREATE POLICY "Users can view own folders" ON folders
    FOR SELECT TO authenticated
    USING (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can manage own folders" ON folders;
CREATE POLICY "Users can manage own folders" ON folders
    FOR ALL TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Note-folder relationships
DROP POLICY IF EXISTS "Users can view own note folders" ON note_folders;
CREATE POLICY "Users can view own note folders" ON note_folders
    FOR SELECT TO authenticated
    USING (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can manage own note folders" ON note_folders;
CREATE POLICY "Users can manage own note folders" ON note_folders
    FOR ALL TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- ============================================
-- 9. STATISTICS UPDATE
-- ============================================

-- Update table statistics for query planner
ANALYZE notes;
ANALYZE folders;
ANALYZE note_folders;
ANALYZE clipper_inbox;
ANALYZE note_tasks;
ANALYZE templates;

-- ============================================
-- 10. FUNCTION FOR EFFICIENT SYNC
-- ============================================

-- Create function to get all changes since a timestamp for a user
CREATE OR REPLACE FUNCTION get_sync_changes(
    p_user_id UUID,
    p_since TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS TABLE (
    table_name TEXT,
    operation TEXT,
    record_id UUID,
    record_data JSONB,
    updated_at TIMESTAMP WITH TIME ZONE
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    -- Get note changes
    SELECT
        'notes'::TEXT as table_name,
        CASE WHEN deleted THEN 'DELETE' ELSE 'UPSERT' END as operation,
        id as record_id,
        jsonb_build_object(
            'id', id,
            'title_enc', encode(title_enc, 'base64'),
            'props_enc', encode(props_enc, 'base64'),
            'deleted', deleted,
            'updated_at', updated_at
        ) as record_data,
        updated_at
    FROM notes
    WHERE user_id = p_user_id
        AND (p_since IS NULL OR updated_at > p_since)

    UNION ALL

    -- Get folder changes
    SELECT
        'folders'::TEXT as table_name,
        CASE WHEN deleted THEN 'DELETE' ELSE 'UPSERT' END as operation,
        id as record_id,
        jsonb_build_object(
            'id', id,
            'name_enc', encode(name_enc, 'base64'),
            'props_enc', encode(props_enc, 'base64'),
            'deleted', deleted,
            'updated_at', updated_at
        ) as record_data,
        updated_at
    FROM folders
    WHERE user_id = p_user_id
        AND (p_since IS NULL OR updated_at > p_since)

    UNION ALL

    -- Get note-folder relationship changes
    SELECT
        'note_folders'::TEXT as table_name,
        'UPSERT' as operation,
        note_id as record_id,
        jsonb_build_object(
            'note_id', note_id,
            'folder_id', folder_id,
            'added_at', added_at
        ) as record_data,
        added_at as updated_at
    FROM note_folders
    WHERE user_id = p_user_id
        AND (p_since IS NULL OR added_at > p_since)

    ORDER BY updated_at ASC;
END;
$$;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION get_sync_changes TO authenticated;

-- ============================================
-- 11. MONITORING AND MAINTENANCE
-- ============================================

-- Create view for monitoring table sizes and performance
CREATE OR REPLACE VIEW table_statistics AS
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_indexes_size(schemaname||'.'||tablename)) AS indexes_size,
    n_live_tup as row_count,
    n_dead_tup as dead_rows,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

-- Grant select permission to authenticated users
GRANT SELECT ON table_statistics TO authenticated;

-- ============================================
-- 12. PARTITIONING FOR SCALE (Optional)
-- ============================================

-- For very large deployments, consider partitioning notes by created_at
-- This is commented out as it requires careful planning and migration

-- CREATE TABLE notes_partitioned (LIKE notes INCLUDING ALL)
-- PARTITION BY RANGE (created_at);

-- CREATE TABLE notes_2025_01 PARTITION OF notes_partitioned
-- FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- CREATE TABLE notes_2025_02 PARTITION OF notes_partitioned
-- FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- ============================================
-- MIGRATION COMPLETED
-- ============================================

-- Log migration completion
DO $$
BEGIN
    RAISE NOTICE 'Phase 3 PostgreSQL optimizations completed successfully';
    RAISE NOTICE 'Indexes created for encrypted data queries';
    RAISE NOTICE 'RLS policies optimized for performance';
    RAISE NOTICE 'Sync function created for efficient data retrieval';
END $$;